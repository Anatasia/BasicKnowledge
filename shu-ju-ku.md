# 

# 

# 三、SQL语句

包括数据定义语言DDL，数据操纵语言DML，数据控制语言DCL。

## 1.数据定义

create，drop，alter

### 1）模式定义

create schema S-T authorization wang 为用户wang定义模式S-T

drop schema &lt;模式名&gt;&lt;cascade\|restrict&gt;

cascade级联：删除模式时，把该模式中所有数据库对象全部删除

restrict限制：若该模式定义了下属的数据库对象（如表、视图等），则拒绝删除语句的执行

### 2）表定义

create table &lt;表名&gt;（列名 数据类型 完整性约束，...，foreign key &lt;属性名&gt; references &lt;表名&gt;（属性名））

alter table &lt;表名&gt;【add &lt;新列名&gt;&lt;数据类型&gt;【完整性约束条件】，drop &lt;完整性约束名&gt;，alter column&lt;列名&gt;&lt;数据类型&gt;】

### 3）视图定义

虚表，从一个或几个基本表（或视图导出的表），只存放视图的定义，不存放数据。

create view &lt;视图名&gt;（列名,...） AS &lt;子查询&gt; with check option，该语句中的子查询不允许有order by 子句或distinct

更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一有意义的转换成对相应基本表的更新。

### 4）索引定义

目的：加快表的查询速度

DBMS一般会自动建立PRIMARY key 和 unique列的索引

索引是关系数据库的内部实现技术，属于内模式范畴。

create index 定义索引时可以定义索引为唯一索引、非唯一索引或聚簇索引。

create \[unique\|claster\] index &lt;索引名&gt; on &lt;表名&gt;（列名，列名）

一个基本表上只能建立一个聚簇索引，在经常查询的列上建立聚簇索引以提高查询效率，经常更新的列上不宜建立聚簇索引。

## 2.数据操纵

insert，update，delete

插入：insert into &lt;表名&gt; 【属性列】 values\[常量\]

修改：update ...set...

删除：delete from ...

## 3.数据控制

revoke，grant

## 4.数据查询

select

## 1）普通查询

a）消除取值重复的行：distinct 关键词，缺省为ALL。

b）确定范围：between ... and...，not between ... and....。

c）确定集合：in&lt;值表&gt;，not in &lt;值表&gt;

d）字符匹配：【not】like ‘&lt;匹配串&gt;’ 【escape ‘换码符’】，换码字符将通配符转义为普通字符。  '%'匹配多个字符，'\_'匹配单个字符。

e）空值：is null或is not null

f）排序 order by：可以按一个或多个属性序列排序，升序ASC，降序DESC。

g）聚集函数：COUNT，SUM， AVG， MAX， MIN。GROUP BY可以细化聚集函数的作用对象。Having 作用于组，从中选择满足条件的组。

### 2）集合查询

a）并Union：union自动去掉重复元组，union all保留重复元祖。

b）交INTERSECT

c）差EXCEPT

参加集合操作的各查询结果列数必须相同，对应项的数据类型也必须相同。

### 3）连接查询

a）等值连接

b）自然连接

c）自身连接：需要给表起别名以示区别

d）外连接：与普通连接的区别：普通连接只输出满足连接条件的元组，外连接以指定表为连接主体，将主体表中不满足连接条件的元组一并输出。

### 4）嵌套查询

a）不相关子查询

由里向外逐层查询。

b）相关子查询

子查询的条件依赖于父查询。主要分为：带有IN谓词的子查询、带有比较运算符的子查询、带有any 或all 的子查询、带有Exists的子查询。

# 四、数据库保护

## 1.完整性

1）数据库的正确性和相容性

2）为维护数据库的完整性，DBMS必须提供完整性约束条件的定义；提供完整性检查的方法违约处理，用check短语检查指定列值应满足条件。

3）完整性约束命名子句 constraint &lt;完整性约束条件名&gt;【primary key\|foreign key\|check】

## 2.安全性

### 1）用户标识和鉴别

### 2）存取控制

#### a）自主存取控制DAC

通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记。

缺点：存在数据的无意泄露。

#### b）强制存取控制MAC

MAC能够保证更高强度的安全性，适用于对数据有严格要求而固定密级分类的部门。

敏感度标记：绝密TOP secret，机密secret，可信confidential，公开public。

主体：活动实体许可证级别

客体：被动实体，文件、基表等

策略：读——许可级别大于等于客体；写——许可级别等于客体；修正规则——许可级别小于等于客体，禁止拥有高级许可级别的主体更新低密级数据。

### 3）授权和回收

用户权限组成：数据对象+操作类型。

grant 权限 on 对象类型  对象名 to 用户 with grant option（可以再授予）

不允许循环授权 u1-&gt;u2-&gt;u3-&gt;u1

revoke update\(sno\) on table student from u3;

### 4）数据库角色

被命名的一组与数据库操作相关的权限。

create role 角色名

grant 权限 on 对象类型 对象名 to 角色

grant role1 to role2/用户 with admin option

revoke 权限 on 对象类型 对象名 from 角色

## 3.恢复技术

### 1）事务

一个数据库操作序列，一个不可分割的工作单元。

#### a）显示定义

Begin transaction SQL语句1，SQL语句2...commit；

Begin transaction SQL语句1，SQL语句2...roll back；

#### b）隐式定义

用户未显示定义时，DBMS缺省规定自动划分事务。

#### c）事务的特性ACID

#### Automicity 原子性

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

#### Consistency 一致性

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

#### Isolation 隔离性

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性

#### 隔离级别

#### 脏读

脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。

#### 不可重复读

不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

#### 虚读（幻读）

幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

#### 隔离级别小结

脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。  
幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

#### MySql数据库提供的4种隔离级别

i\)Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。

ii\)Repeatable read \(可重复读\)：可避免脏读、不可重复读的发生。

iii\)Read committed \(读已提交\)：可避免脏读的发生。

iv\)Read uncommitted \(读未提交\)：最低级别，任何情况都无法保证。

在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read \(可重复读\)

而在Oracle数据库中，只支持Serializable \(串行化\)级别和Read committed \(读已提交\)这两种级别，其中默认的为Read committed级别。

隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。

#### Durability 持续性

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### 2）故障

影响：数据库本身被破坏；数据库未被破坏，但数据不正确。

#### a）事务内部故障

非预期故障，包括运算溢出、并发事务死锁、违反完整性限制等。

解决思路：撤销事务（undo）

#### b）系统故障

分类：指定类型硬件错误、操作系统故障、DBMS代码错误、系统断电，

后果：系统正常运行被破坏；正在运行事务非正常终止；内存中数据缓冲区信息全部丢失；不破坏数据库；

解决思路：事务未提交，强行撤销（undo）；事务已提交，缓冲区信息未写到磁盘，重做已提交事件。

#### c）介质故障

装入副本，重做自此时开始的所有成功事务。重装备份+redo

#### d）计算机病毒

### 3）恢复的实现技术

#### 基本原理

冗余！！！

#### 如何建立冗余

#### a）数据转储backup

#### 静态转储

优点：实现简单，得到数据一致的副本。

缺点：降低数据的可用性，转储需要等待当前正运行事务结束，新事务需等待转储结束。

#### 动态转储

转储操作与用户事务并发运行，允许对数据库存取和修改。

优点：不用等待正在运行的事务结束，不影响新事务的运行。

缺点：不能保证副本中数据正确有效。

解决办法：需将动态转储期间事务对数据库的修改活动登记下来，建立日志文件。

#### 增量转储

#### 海量转储

#### b）登陆日志文件logging

日志文件格式：记录为单位——事务开始标记、结束标记、所有更新操作事务标记、操作类型、对象、旧值、新值；数据块为单位——事务标记、被更新数据块。

作用：事务、系统、介质故障恢复

基本原则：先写日志，后写数据库

具有检查点的恢复技术：在日志文件中增加检查点记录，增加重新开始文件。

检查点记录内容：建立检查点时刻正在执行的事务清单，这些事务最近一个日志记录的地址。

### 4）数据库的可用性

提高数据库的可用性的方案：镜像。

## 4.并发



