# 一.索引

## 1.索引的类型

### 1）B-Tree索引

        B-Tree意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

### 2）Hash索引

        哈希索引是基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

        MySql中只有memory引擎显示支持哈希索引，这也是Memory引擎的默认索引类型，其同时支持B-Tree索引。  


      索引本身只存储对应的哈希值，所以查找速度快。但也存在相应的限制：1）哈希索引只存储哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。2）哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。3）哈希索引不支持部分索引序列匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值。4）哈希索引只支持等值查询，也不支持任何范围查询。5）访问哈希索引的速度非常快，除非有很多哈希冲突。当出现冲突时，存储引擎必须遍历链表中的所有的行指针，逐行进行比较，直到找到所有符合条件的行。6）如果哈希冲突多，索引维护的代价很高。

## 2.索引的优点

1）索引大大减少了服务器需要扫描的数据量；

2）索引可以帮助服务器避免排序和临时表；

3）索引可以将随机I/O变成顺序I/O。

## 3.索引的缺点

1）减慢了数据的录入速度；

2）增加了数据库的尺寸大小。

## 4.高性能的索引策略

1）使用独立的列：如果查询中的列不是独立的，则MySql就不会使用索引。

2）前缀索引和索引的选择性：a\)索引的选择性是指不重复的索引值和数据表的总数的比值，索引的选择性越高则查询效率越高；b）唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

3）多列索引

4）选择合适的索引列顺序

5）聚簇索引：a）聚簇索引不是一种单独的索引类型而是一种数据存储方式。具体的细节依赖于其实现方式。b）当表有聚簇索引时，它的数据行实际上存放在索引的叶子页。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

# 二、基本概念

## 1.数据模型

1）分类：概念数据模型、逻辑数据模型、物理模型。

2）组成要素：数据结构、数据操作、完整性约束条件。

3）相关定义

a）实体：客观存在并且相互区别的事物。人、事、物或抽象概念。

b）属性：实体所具有的某一特性。

c）码：唯一标识实体的属性集。

d）域：属性值的取值范围。

e）联系

实体内部的联系和实体之间的联系：一对一，一对多，多对多。

联系本身也是一种实体型，可以有属性。

# 2.关系数据模型

1）关系必须是规范化的，满足一定的规范条件。

2）最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中有表。

3）完整性分类：实体完整性、参照完整性、用户定义的完整性。

## 3.数据库的三级模式

1）外模式：（用户世界）数据库用户使用的局部数据的逻辑结构和特征的描述。数据库用户的数据视图是与某一应用有关的数据的逻辑表示。用途：保证数据库安全性的有力措施，每个用户只能看见和访问所对应的外模式中的数据。

2）模式：（程序员世界）数据的逻辑结构、数据之间的联系、有关安全性、完整性的要求。模式是对全体数据的逻辑结构和特征的描述，所有用户的公共数据视图，综合所有用户的需求。

3）内模式：（机器世界）存储模式，依赖全局逻辑结构、独立于用户视图（即外模式）。

## 4.二级影像

1）外模式/模式影像：位于外模式和模式之间。

2）模式/内模式：位于模式和内模式之间。

映像分别保证数据的逻辑独立性和物理独立性。保证数据的稳定性。  


## 5.CAP理论

C（Consistency）一致性，A（Availability）可用性，P（Partition Tolorance）分区容错性。

定理：任何分布式系统只同时满足以上二点，没法三者兼顾。  


## 6.关系型数据库

### 1）码

a）候选码：唯一标识一个元组（包括一个属性或一组属性）。

b）全码：最极端的情况，关系模式的所有属性组是这个关系模式的候选码。

c）主码：一个关系有多个候选码，选择其中一个作为主码。

d）主属性：候选码中的诸属性称为主属性。

### 2）关系模式R（U，D,DOM,F）

R：关系名

U：组成该关系的属性名集合。

D：属性组U中的属性所来自的域。

DOM：属性向域的映射集合。

F：属性间的数据以来关系集合。

3）关系的三类完整性约束条件

a）实体完整性和参照完整性是关系模型必须满足的完整性约束条件，成为关系的两个不变性，应该由关系系统自动支持。

b）用户定义的完整性：应用领域需要遵循的约束条件，体现具体领域的语义约束。

c）实体完整性：若属性A是基本关系R的主属性，则属性A不能取空值。

d）参照完整性：外码——F是R的一个或一组属性，但不是关系R的码。若F与关系S的主码Ks相对应，则F是R的外码。R成为参照关系，S称为被参照关系或目标关系。规则——若属性（属性组）F是R的外码，它与S的主码Ks相对应，则对于R中的每个原组在F上的值必须为空值或者等于S中某个元组的主码值。

# 7.存储过程

存储过程是一个预编译的SQL语句，优点是运行模块化设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。

# 三、SQL语句

包括数据定义语言DDL，数据操纵语言DML，数据控制语言DCL。

## 1.数据定义

create，drop，alter

### 1）模式定义

create schema S-T authorization wang 为用户wang定义模式S-T  


drop schema &lt;模式名&gt;&lt;cascade\|restrict&gt;  


cascade级联：删除模式时，把该模式中所有数据库对象全部删除  


restrict限制：若该模式定义了下属的数据库对象（如表、视图等），则拒绝删除语句的执行  


### 2）表定义

create table &lt;表名&gt;（列名 数据类型 完整性约束，...，foreign key &lt;属性名&gt; references &lt;表名&gt;（属性名））  


alter table &lt;表名&gt;【add &lt;新列名&gt;&lt;数据类型&gt;【完整性约束条件】，drop &lt;完整性约束名&gt;，alter column&lt;列名&gt;&lt;数据类型&gt;】  


### 3）视图定义

虚表，从一个或几个基本表（或视图导出的表），只存放视图的定义，不存放数据。  


create view &lt;视图名&gt;（列名,...） AS &lt;子查询&gt; with check option，该语句中的子查询不允许有order by 子句或distinct  


更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一有意义的转换成对相应基本表的更新。  


### 4）索引定义

目的：加快表的查询速度  


DBMS一般会自动建立PRIMARY key 和 unique列的索引  


索引是关系数据库的内部实现技术，属于内模式范畴。  


create index 定义索引时可以定义索引为唯一索引、非唯一索引或聚簇索引。  


create \[unique\|claster\] index &lt;索引名&gt; on &lt;表名&gt;（列名，列名）  


一个基本表上只能建立一个聚簇索引，在经常查询的列上建立聚簇索引以提高查询效率，经常更新的列上不宜建立聚簇索引。  


## 2.数据操纵

insert，update，delete

插入：insert into &lt;表名&gt; 【属性列】 values\[常量\]  


修改：update ...set...  


删除：delete from ...  


## 3.数据控制

revoke，grant

## 4.数据查询

select

## 1）普通查询

a）消除取值重复的行：distinct 关键词，缺省为ALL。

b）确定范围：between ... and...，not between ... and....。

c）确定集合：in&lt;值表&gt;，not in &lt;值表&gt;

d）字符匹配：【not】like ‘&lt;匹配串&gt;’ 【escape ‘换码符’】，换码字符将通配符转义为普通字符。  '%'匹配多个字符，'\_'匹配单个字符。

e）空值：is null或is not null

f）排序 order by：可以按一个或多个属性序列排序，升序ASC，降序DESC。

g）聚集函数：COUNT，SUM， AVG， MAX， MIN。GROUP BY可以细化聚集函数的作用对象。Having 作用于组，从中选择满足条件的组。 

### 2）集合查询

a）并Union：union自动去掉重复元组，union all保留重复元祖。

b）交INTERSECT

c）差EXCEPT

参加集合操作的各查询结果列数必须相同，对应项的数据类型也必须相同。

### 3）连接查询

a）等值连接

b）自然连接

c）自身连接：需要给表起别名以示区别

d）外连接：与普通连接的区别：普通连接只输出满足连接条件的元组，外连接以指定表为连接主体，将主体表中不满足连接条件的元组一并输出。

### 4）嵌套查询

a）不相关子查询

由里向外逐层查询。

b）相关子查询

子查询的条件依赖于父查询。主要分为：带有IN谓词的子查询、带有比较运算符的子查询、带有any 或all 的子查询、带有Exists的子查询。

# 四、数据库保护

## 1.完整性

1）数据库的正确性和相容性

2）为维护数据库的完整性，DBMS必须提供完整性约束条件的定义；提供完整性检查的方法违约处理，用check短语检查指定列值应满足条件。

3）完整性约束命名子句 constraint &lt;完整性约束条件名&gt;【primary key\|foreign key\|check】

## 2.安全性

### 1）用户标识和鉴别

### 2）存取控制

#### a）自主存取控制DAC

通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记。

缺点：存在数据的无意泄露。

#### b）强制存取控制MAC

MAC能够保证更高强度的安全性，适用于对数据有严格要求而固定密级分类的部门。

敏感度标记：绝密TOP secret，机密secret，可信confidential，公开public。

主体：活动实体许可证级别

客体：被动实体，文件、基表等

策略：读——许可级别大于等于客体；写——许可级别等于客体；修正规则——许可级别小于等于客体，禁止拥有高级许可级别的主体更新低密级数据。

### 3）授权和回收

用户权限组成：数据对象+操作类型。  


grant 权限 on 对象类型  对象名 to 用户 with grant option（可以再授予）  


不允许循环授权 u1-&gt;u2-&gt;u3-&gt;u1  


revoke update\(sno\) on table student from u3;  


### 4）数据库角色

被命名的一组与数据库操作相关的权限。  


create role 角色名  


grant 权限 on 对象类型 对象名 to 角色  


grant role1 to role2/用户 with admin option  


revoke 权限 on 对象类型 对象名 from 角色  


## 3.恢复技术

### 1）事务

一个数据库操作序列，一个不可分割的工作单元。  


#### a）显示定义

Begin transaction SQL语句1，SQL语句2...commit；  


Begin transaction SQL语句1，SQL语句2...roll back；  


#### b）隐式定义

用户未显示定义时，DBMS缺省规定自动划分事务。  


#### c）事务的特性ACID

#### Automicity 原子性

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。  


#### Consistency 一致性

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

#### Isolation 隔离性

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性  


#### 隔离级别

#### 脏读

脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。  


当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。  


#### 不可重复读

不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

#### 虚读（幻读）

幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。  


#### 隔离级别小结

脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。  
幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

#### MySql数据库提供的4种隔离级别

i\)Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。

ii\)Repeatable read \(可重复读\)：可避免脏读、不可重复读的发生。

iii\)Read committed \(读已提交\)：可避免脏读的发生。

iv\)Read uncommitted \(读未提交\)：最低级别，任何情况都无法保证。

在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read \(可重复读\)  


而在Oracle数据库中，只支持Serializable \(串行化\)级别和Read committed \(读已提交\)这两种级别，其中默认的为Read committed级别。  


隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。  


#### Durability 持续性 

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。  


### 2）故障

影响：数据库本身被破坏；数据库未被破坏，但数据不正确。

#### a）事务内部故障

非预期故障，包括运算溢出、并发事务死锁、违反完整性限制等。

解决思路：撤销事务（undo）

#### b）系统故障

分类：指定类型硬件错误、操作系统故障、DBMS代码错误、系统断电，

后果：系统正常运行被破坏；正在运行事务非正常终止；内存中数据缓冲区信息全部丢失；不破坏数据库；

解决思路：事务未提交，强行撤销（undo）；事务已提交，缓冲区信息未写到磁盘，重做已提交事件。

#### c）介质故障

装入副本，重做自此时开始的所有成功事务。重装备份+redo  


#### d）计算机病毒

### 3）恢复的实现技术

#### 基本原理

冗余！！！

#### 如何建立冗余

#### a）数据转储backup

#### 静态转储

优点：实现简单，得到数据一致的副本。

缺点：降低数据的可用性，转储需要等待当前正运行事务结束，新事务需等待转储结束。

#### 动态转储

转储操作与用户事务并发运行，允许对数据库存取和修改。

优点：不用等待正在运行的事务结束，不影响新事务的运行。  


缺点：不能保证副本中数据正确有效。

解决办法：需将动态转储期间事务对数据库的修改活动登记下来，建立日志文件。

#### 增量转储

#### 海量转储

#### b）登陆日志文件logging

日志文件格式：记录为单位——事务开始标记、结束标记、所有更新操作事务标记、操作类型、对象、旧值、新值；数据块为单位——事务标记、被更新数据块。

作用：事务、系统、介质故障恢复  


基本原则：先写日志，后写数据库  


具有检查点的恢复技术：在日志文件中增加检查点记录，增加重新开始文件。  


检查点记录内容：建立检查点时刻正在执行的事务清单，这些事务最近一个日志记录的地址。  


### 4）数据库的可用性

提高数据库的可用性的方案：镜像。

## 4.并发



